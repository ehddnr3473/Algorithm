//
//  계수 정렬.swift
//  Algorithm
//
//  Created by 김동욱 on 2023/01/08.
//

/*
 계수 정렬(Count Sort)
 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘
    - 데이터의 크기가 한정되어 있을 때
    - 데이터의 크기가 많이 중복되어 있을수록 유리
 <시간 복잡도>
 모든 데이터가 양의 정수인 상황에서 데이터의 개수를 N, 데이터 중 최대값의 크기를 K라고 할 때, 계수 정렬의 시간 복잡도는 O(N + K). 계수 정렬은 앞에서부터 데이터를 하나씩 확인하면서 리스트에서 적절한 인덱스의 값을 1씩 증가시킬 뿐만 아니라, 추후에 리스트의 각 인덱스에 해당하는 값들을 확인할 때 데이터 중 최댓값의 크기만큼 반복을 수행해야 하기 때문. 따라서 데이터의 범위만 한정되어 있다면 효과적으로 사용할 수 있으며 항상 빠르게 동작함.
 <공간 복잡도>
 계수 정렬의 공간 복잡도는 O(N + K).
 심각한 비효율성을 초래할 수 있음. 데이터가 0과 999,999 단 2개만 존재하는 상황에도 리스트의 크기가 100만개가 되도록 선언해야 함. 따라서 동일한 값을 가지는 데이터가 여러 개 등장할 때 적합함. 예를 들어 성적의 경우 100점을 맞은 학생이 여러 명일 수 있기 때문에 계수 정렬이 효과적. 반면에 퀵 정렬은 일반적인 경우에서 평균적으로 빠르게 동작하기 때문에 데이터의 특성을 파악하기 어렵다면 퀵 정렬을 이용하는 것이 유리함.
 */
import Foundation

func countSorting() {
    let array = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]
    
    // 모든 범위를 포함하는 배열 선언 - 모든 값은 0으로 초기화
    var count = Array(repeating: 0, count: array.max()! + 1)
    
    for index in array.indices {
        count[array[index]] += 1 // 각 데이터에 해당하는 인덱스의 값 증가
    }
    
    // count에 기록된 정렬 정보 확인
    for i in 0..<count.count {
        for _ in 0..<count[i] {
            print(i, terminator: " ")
        }
    }
    print("")
}

//countSorting()
